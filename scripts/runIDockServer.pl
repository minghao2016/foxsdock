#!/usr/bin/perl -w

use strict;
use FindBin;
use Getopt::Long;

if($#ARGV < 2) {
  print "runIDock.pl <receptor_pdb> <ligand_pdb> [--saxs] [--em3d] [--em2d] [--receptor_rtc] [--ligand_rtc] [--cxms] [--complex_type]\n";
  print "--saxs = saxs_file Specify the file name of the complex SAXS profile\n";
  print "--em3d = mrc_file Specify the file name of the complex density map in mrc format\n";
  print "--em2d = image_file1 image_file2 ... Specify the file names of up to 5 complex 2D class averages in PGM format (P2)\n";
  print "--cxms = cross_links_file Specify cross links file\n";
  print "--receptor_rtc = rtc_file Specify the file name of the receptor NMR residue type content\n";
  print "--ligand_rtc = rtc_file Specify the file name of the ligand NMR residue type content\n";
  print "--complex_type = EI/AA/other Use this order for receptor-ligand: antibody-antigen, enzyme-inhibitor!\n";
  print "--pixel_size = pixel_size Specify the pixel size for EM2D images\n";
  print "--saxs_receptor_pdb = receptor_pdb Specify additional receptor structure for SAXS scoring with modeled missing atoms/residues.\nThis structure should be aligned to the input receptor!\n";
  print "--saxs_ligand_pdb = ligand_pdb Specify additional ligand structure for SAXS scoring with modeled missing atoms/residues.\nThis structure should be aligned to the input ligand!\n";    
  print "--receptor_site = receptor_site Specify receptor binding site residues\n";
  print "--ligand_site = ligand_site Specify ligand binding site residues\n";
  print "--prefix = myprefix Add prefix string to filenames generated by the current run\n";
  print "--precision = 1/2/3 Sampling precision for rigid docking: 1-normal, 2-medium, 3-high. The higher the precision, the higher are the run times\n";
  print "--weighted_saxs_score If specified, weighted scoring that accounts for monomers contributions is used\n";
  exit;
}

# software directories, please update to your path!
my $home = "$FindBin::Bin";


my $receptor = $ARGV[0];
my $ligand = $ARGV[1];
if(-e $receptor and -e $ligand) {
  print "Receptor file name = $receptor, ligand file name = $ligand\n";
} else {
  print "Please provide receptor and ligand files\n"; exit;
}

# read options
my $saxs_file = '';     # SAXS profile
my $map_file = '';      # EM 3d density map
my @class_averages;     # EM 2d class averages
my $cross_links_file = ''; # cross links file
my $receptor_rtc = '';  # NMR residue type content
my $ligand_rtc = '';
my $type = '';
my $prefix = '';
my $pixel_size = 0.0;
my $saxs_receptor_pdb = '';
my $saxs_ligand_pdb = '';
my $precision = 1; # TODO: change to 2 for download?
my $weighted_saxs_score = '';

my $result = GetOptions("saxs=s" => \$saxs_file,
                        "em3d=s" => \$map_file,
                        "em2d=s{1,20}" => \@class_averages,
			"cxms=s" => \$cross_links_file,
                        "receptor_rtc=s" => \$receptor_rtc,
                        "ligand_rtc=s" => \$ligand_rtc,
                        "complex_type=s" => \$type,
			"pixel_size=f" => \$pixel_size,
			"saxs_receptor_pdb=s" => \$saxs_receptor_pdb,
			"saxs_ligand_pdb=s" => \$saxs_ligand_pdb,
                        "prefix=s" => \$prefix,
			"precision=i" => \$precision,
			"weighted_saxs_score" => \$weighted_saxs_score);

if(length $saxs_file > 0) { print "SAXS profile given $saxs_file\n"; }
if(length $map_file > 0) { print "EM 3D density map given $map_file\n"; }
my $class_average_list = '';
if($#class_averages >=0) { print "2D class averages given: ";
                            foreach(@class_averages) { $class_average_list .= " $_ "; }
                            print "$class_average_list\n"; }
if($#class_averages >=0 && $pixel_size <= 0.0) { print "Please specify pixel size for 2D images with --pixel_size option\n"; exit; }
if(length $cross_links_file > 0) { print "Cross links file give $cross_links_file\n"; }
if(length $receptor_rtc > 0) { print "Receptor residue type content given $receptor_rtc\n"; }
if(length $ligand_rtc > 0) { print "Ligand residue type content given $ligand_rtc\n"; }
if(length $type > 0) { print "Complex type given $type\n"; } else { $type="other"; }
if($type ne "EI" and $type ne "AA" and $type ne "other") {
  print "Invalid complex type, using default!\n";
  $type="Default";
}
if(length $prefix > 0) { print "File prefix given $prefix\n"; $prefix .= '_'; }

if($precision != 1 and $precision != 2 and $precision != 3) {
  print "Invalid precision value, can get 1, 2 or 3. Using default value of 1. see Help for details\n";
  $precision = 1;
}

if(length $saxs_file == 0 and length $map_file == 0 and length $class_average_list == 0 and
   length $cross_links_file == 0 and length $receptor_rtc == 0 and length $ligand_rtc == 0) { # no data given
  print "Please provide one or more types of experimental data: SAXS, EM3D, EM2D, CXMS or NMR residue type content\n";
  exit;
}
# TODO: validate that all files exist


# STEP 1: run PatchDock

my $cmd;
# generate PatchDock parameter file
if($precision == 1) {
  $cmd = "buildParams.pl $receptor $ligand 4.0 $type";
} else {
  if($precision == 2) {
    $cmd = "buildParams.pl $receptor $ligand 2.0 $type";
  } else {
    $cmd = "buildParamsFine.pl $receptor $ligand 2.0 $type";
  }
}
print "$cmd\n";
`$cmd`;

if(-e "distance_constraints.txt") {
  `echo \"distanceConstraintsFile distance_constraints.txt\" >> params.txt`;
}

# run PatchDock
my $patch_dock_out_file = $prefix . "docking.res";
$cmd = "patch_dock.Linux params.txt $patch_dock_out_file";
if(-e "$patch_dock_out_file") {  # recovery
  my $count1 = int `wc -l < $patch_dock_out_file`;
  if($count1 > 36) {
    print "Skipping PatchDock for $receptor\n";
  } else {
    print "$cmd\n";
    `$cmd`;
  }
} else {
  print "$cmd\n";
  `$cmd`;
}

# prepare transformation file
$cmd = "$home/PatchDockOut2Trans.pl $patch_dock_out_file > trans_pd";
if($precision == 1) {
  $cmd = "$home/PatchDockOut2Trans.pl $patch_dock_out_file | head -5000 > trans_pd";
}
print "$cmd\n";
`$cmd`;

if ( ! -s "trans_pd") {
  print "ERROR: PatchDock found no docking solutions.\n";
  print "See patch_dock.log for more information.\n";
  exit;
}

# swap in case of AA
if($type eq "AA") {
  my $tmp = $receptor;
  $receptor = $ligand;
  $ligand = $tmp;
  $tmp = $saxs_receptor_pdb;
  $saxs_receptor_pdb = $saxs_ligand_pdb;
  $saxs_ligand_pdb = $tmp;
}


# STEP 2A: run score with experimental data

# NMR residue type content
my $nmr_rtc_out_file = '';
if(length $receptor_rtc > 0 or length $ligand_rtc > 0) {
  if($type eq "AA") { $receptor_rtc=$ligand_rtc; $ligand_rtc = "-"; } # TODO: check that length $receptor_rtc > 0
  $nmr_rtc_out_file = $prefix."nmr_rtc_score.res";
  $cmd = "nmr_rtc_score $receptor $ligand trans_pd $receptor_rtc $ligand_rtc -o $nmr_rtc_out_file";
  print "$cmd\n";
  if(-e $nmr_rtc_out_file) {  # recovery
    my $count1 = int `wc -l < trans_pd`;
    my $count2 = int `wc -l < $nmr_rtc_out_file`;
    if($count2 < $count1) {
      `$cmd`;
    } else {
      print "Skipping NMR score for $receptor\n";
    }
  } else {
    `$cmd`;
  }
}

# SAXS: run SAXS scoring rg + chi
my $saxs_out_file = '';
if(length $saxs_file > 0) {
  $saxs_out_file = $prefix."saxs_score.res";
  my $saxs_receptor = $receptor;
  my $saxs_ligand = $ligand;
  if(length $saxs_receptor_pdb > 0) { $saxs_receptor = $saxs_receptor_pdb; }
  if(length $saxs_ligand_pdb > 0) { $saxs_ligand = $saxs_ligand_pdb; }
  #$cmd = "saxs_score $receptor $ligand trans_pd $saxs_file -f -o $saxs_out_file"; # use offset
  #$cmd = "saxs_score $saxs_receptor $saxs_ligand trans_pd $saxs_file -o $saxs_out_file";
  $cmd = "saxs_score $saxs_receptor $saxs_ligand trans_pd $saxs_file -o $saxs_out_file --no_filtering_by_rg -a";
  if($weighted_saxs_score) { $cmd .= " -t"; }
  print "$cmd\n";
  if(-e $saxs_out_file) {  # recovery
    my $count1 = int `wc -l < trans_pd`;
    my $count2 = int `wc -l < $saxs_out_file`;
    if($count2 < $count1) {
      `$cmd`;
    } else {
      print "Skipping SAXS score for $receptor\n";
    }
  } else {
  `$cmd`;
  }
}

# EM2D
my $em2d_out_file = '';
if(length $class_average_list > 0) {
  $em2d_out_file = $prefix."em2d_score.res";
  $cmd = "em2d_score $receptor $ligand trans_pd $class_average_list -o $em2d_out_file -n 200 -s $pixel_size"; 
  print "$cmd\n";
  if(-e $em2d_out_file) {  # recovery
    my $count1 = int `wc -l < trans_pd`;
    my $count2 = int `wc -l < $em2d_out_file`;
    if($count2 < $count1) {
      `$cmd`;
    } else {
      print "Skipping EM2D score for $receptor\n";
    }
  } else {
    `$cmd`;
  }
}

# EM3D
my $em3d_out_file = '';
if(length $map_file > 0) {
  $em3d_out_file = $prefix."em3d_score.res";
  $cmd = "em3d_score $receptor $ligand trans_pd $map_file -o $em3d_out_file -s";
  print "$cmd\n";
  if(-e $em3d_out_file) {  # recovery
    my $count1 = int `wc -l < trans_pd`;
    my $count2 = int `wc -l < $em3d_out_file`;
    if($count2 < $count1) {
      `$cmd`;
    } else {
      print "Skipping EM3D fit for $receptor\n";
    }
  } else {
  `$cmd`;
  }
}

# CXMS
my $cxms_out_file = '';
if(length $cross_links_file > 0) {
  $cxms_out_file = $prefix."cxms_score.res";
  $cmd = "cross_links_score $receptor $ligand trans_pd $cross_links_file -o $cxms_out_file";
  print "$cmd\n";
  `$cmd`;
}

# SOAP
my $soap_out_file = $prefix."soap_score.res";
$cmd = "soap_score $receptor $ligand trans_pd -o $soap_out_file";
print "$cmd\n";
`$cmd`;


# STEP 2B: filter and combine scores if needed
my $data_count = 1; # we always have SOAP score
my $data_types = '';
my $nmr_weight = '', my $saxs_weight = '', my $em2d_weight = '', my $em3d_weight = '', my $cxms_weight = '';
if(length $prefix > 0) {
  $data_types .= "_";
  $data_types .= substr $prefix, 0, (length $prefix)-1;
}
if(length $nmr_rtc_out_file > 0)  { $data_count++; $data_types .= "_nmr_rtc"; $nmr_weight = 1.0; }
if(length $saxs_out_file > 0) { $data_count++; $data_types .= "_saxs"; $saxs_weight = 1.0; }
if(length $em3d_out_file > 0) { $data_count++; $data_types .= "_em3d"; $em3d_weight = 1.0; }
if(length $em2d_out_file > 0) { $data_count++; $data_types .= "_em2d"; $em2d_weight = 1.0; }
if(length $cxms_out_file > 0) { $data_count++; $data_types .= "_cxms"; $cxms_weight = 1.0; }

# combine score
my $combined_out_file = "combined".$data_types.".res";
$cmd = "combine_scores $nmr_rtc_out_file $nmr_weight $saxs_out_file $saxs_weight $em3d_out_file $em3d_weight $em2d_out_file $em2d_weight $cxms_out_file $cxms_weight $soap_out_file 1.0 > $combined_out_file";
print "$cmd\n";
`$cmd`;
my $trans_field = $data_count*2 + 5;
`cut -d '|' -s --output-delimiter=' ' -f 1,2,$trans_field $combined_out_file | grep -v '#' > trans_for_cluster`;


# STEP 2C: cluster
my $clustered_out_file = "clustered".$data_types.".res";
$cmd = "interface_cluster.linux $receptor $ligand trans_for_cluster 4.0 $clustered_out_file";
print "$cmd\n";
`$cmd`;


# Final scoring - extract scores for transformation and recompute z-scores relative to the new set

# prepare transformations file
my $num = 5000;
if(length $cxms_out_file > 0) { $num=2000; }
if(length $em3d_out_file > 0) { $num=1000; }
my $trans_file = "trans_final".$data_types;
`cut -s -d '|' -f1,5 --output-delimiter=' ' $clustered_out_file | head -$num > $trans_file`;

my $header_line = "\"     # |  Score  | filt| ZScore |";
# NMR residue type content
my $nmr_rtc_out_file2 = '';
if(length $receptor_rtc > 0 or length $ligand_rtc > 0) {
  $nmr_rtc_out_file2 = $prefix."_nmr_rtc_scoref.res";
  $cmd = "$home/extract_scores.pl $nmr_rtc_out_file $trans_file > tmp";
  print "$cmd\n";
  `$cmd`;
  $cmd = "recompute_zscore tmp > $nmr_rtc_out_file2";
  print "$cmd\n";
  `$cmd`;
  $header_line .= "NMR-RTC | Zscore |";
}
# SAXS
my $saxs_out_file2 = '';
if(length $saxs_file > 0) {
  $saxs_out_file2 = $prefix."saxs_scoref.res";
  $cmd = "$home/extract_scores.pl $saxs_out_file $trans_file > tmp";
  print "$cmd\n";
  `$cmd`;
  $cmd = "recompute_zscore tmp > $saxs_out_file2";
  print "$cmd\n";
  `$cmd`;
  $header_line .= "  SAXS  | Zscore |";
}
# EM2D
my $em2d_out_file2 = '';
if(length $class_average_list > 0) {
  $em2d_out_file2 = $prefix."em2d_scoref.res";
  $cmd = "$home/extract_scores.pl $em2d_out_file $trans_file > tmp";
  print "$cmd\n";
  `$cmd`;
  $cmd = "recompute_zscore tmp > $em2d_out_file2";
  print "$cmd\n";
  `$cmd`;
  $header_line .= "  EM2D  | Zscore |";
}
# EM3D
my $em3d_out_file2 = '';
if(length $map_file > 0) {
  $em3d_out_file2 = $prefix."em3d_scoref.res";
  $cmd = "$home/extract_scores.pl $em3d_out_file $trans_file > tmp";
  print "$cmd\n";
  `$cmd`;
  $cmd = "recompute_zscore tmp 1 > $em3d_out_file2";
  print "$cmd\n";
  `$cmd`;
  $header_line .= "  EM3D  | Zscore |";
}
# CXMS
my $cxms_out_file2 = '';
if(length $cross_links_file > 0) {
  $cxms_out_file2 = $prefix."cxms_scoref.res";
  $cmd = "$home/extract_scores.pl $cxms_out_file $trans_file > tmp";
  print "$cmd\n";
  `$cmd`;
  $cmd = "recompute_zscore tmp 1 > $cxms_out_file2";
  print "$cmd\n";
  `$cmd`;
  $header_line .= "  CXMS  | Zscore |";
}
# SOAP
my $soap_out_file2 = $prefix."soap_scoref.res";
$cmd = "$home/extract_scores.pl $soap_out_file $trans_file > tmp";
print "$cmd\n";
`$cmd`;
$cmd = "recompute_zscore tmp > $soap_out_file2";
print "$cmd\n";
`$cmd`;
$header_line .= "  SOAP     | Zscore |";



# combine scores
$cmd = "combine_scores $nmr_rtc_out_file2 $nmr_weight $saxs_out_file2 $saxs_weight $em3d_out_file2 $em3d_weight $em2d_out_file2 $em2d_weight $cxms_out_file2 $cxms_weight $soap_out_file2 1.0 > combined_final.res";
print "$cmd\n";
`$cmd`;

# TODO: change header to data names and renumber
my $results_file = "results".$data_types.".txt";
my $header = "\"receptorPdb Str $receptor\nligandPdb Str $ligand\"";
$header_line .= " Transformation\"";
`echo $header > $results_file`;
`echo $header_line >> $results_file`;
`sort -nk3 combined_final.res | grep -v Score | cut -d '|' -f2- | nl -s ' | ' >> $results_file`;
`rm -f tmp`;

# validation - rmsd
$trans_field = $data_count*2 + 5;
`sort -nk3 combined_final.res | grep -v Score | cut -d '|' -f1,$trans_field --output-delimiter=' ' > trans_for_rmsd`;
$cmd = "$home/rmsd3.linux $receptor $receptor $ligand $ligand trans_for_rmsd";
print "$cmd\n";
`$cmd`;
my $complex_size = countCaAtoms($receptor) + countCaAtoms($ligand);
my $line = `tail -n1 rmsd.res`;
my $rank_file = "ranks".$data_types.".txt";
open OUT, ">$rank_file";
print OUT "$receptor, $data_types, ";
my @tmp = split(' ', $line);
printf OUT " %4d , %5.2f , %5.2f , %4d , %5.2f , %5.2f , %4d , %5.2f , %5.2f, %4d\n", $tmp[1], $tmp[2], $tmp[3],  $tmp[5], $tmp[6], $tmp[7],  $tmp[9], $tmp[10], $tmp[11], $complex_size;
close OUT;


sub countCaAtoms {
  my $filename = shift;
  open FILE, "<$filename" or die "Can't open file: $filename";
  my @atomLines =  grep /(^ATOM|^HETATM)/, <FILE>;
  my $atomsNumber = 0;
  foreach (@atomLines) {
    if(substr($_,13,3) eq "CA ") {
      $atomsNumber++;
    }
  }
  close FILE;
  return $atomsNumber;
}
